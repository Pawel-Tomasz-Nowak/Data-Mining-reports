---
title: "Sprawozdanie z listy 1"
subtitle: "Eksploracja danych"
author: "Marta Stankiewicz, Paweł Nowak  \n numery albumów: 282244 282223"
date: "`r Sys.Date()`"
header-includes:
   - \usepackage[OT4]{polski}
   - \usepackage[utf8]{inputenc}
   - \usepackage{graphicx}
   - \usepackage{float}
output: 
  pdf_document:
    toc: true
    fig_caption: yes
    fig_width: 5 
    fig_height: 4 
    number_sections: true
fontsize: 12pt 
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(warning = FALSE, message = FALSE) 
knitr::opts_chunk$set(fig.pos = "H", out.extra = "", fig.align = "center")
```



# Etap 1. Przygotowanie danych. Podstawowe informacje o danych.

```{r Read data and libraries, include=FALSE}
library(dplyr)
library(tidyr)
library(kableExtra)
library(knitr)

# Wczytywanie ramki danych.
dane <- read.csv("WA_Fn-UseC_-Telco-Customer-Churn.csv")


```

```{r dtypes casting, counting rows and cols, include=FALSE}
# Ile jest wierszy, a ile - zmiennych?
n.row <- nrow(dane) # 7043 wierszy.
n.col <- ncol(dane) # 21 kolumn.



# Dane zawierają sporo zmiennych jakościowych nieporzadkowych, które zostały błędnie wczytane jako zmienne typu napis. 
vars.to.cast <- c("gender", "SeniorCitizen", "Partner", "Dependents", "PhoneService", "MultipleLines",
                  "InternetService", "OnlineSecurity", "OnlineBackup", "DeviceProtection",
                  "TechSupport", "StreamingTV", "StreamingMovies", "Contract", "PaperlessBilling",
                  "PaymentMethod", "Churn")

# Dokonaj konwersji na typ `factor`.
dane[vars.to.cast] <- lapply(dane[vars.to.cast], as.factor)

```




```{r missing values handling, include=FALSE}
# Znajdź cechy, które zawierają (standardowo kodowane) wartości brakujące
n.missing <- dane %>% 
  summarize(across(everything(), function(x) { sum(is.na(x)) } ) ) %>% 
  pivot_longer( everything(), names_to = "variable", values_to = "na.count" ) %>%
  filter(na.count > 0)


```

## Opis danych, rozmiar ramki danych, typy danych.

Zbiór danych, którym sie zajmujemy, zawiera informacje o **`r n.row`** klientach sieci sklepów **Telco**, która oferuje różne usługi z branży telekomunikacji, rozrywki, Internetu itp.\
Każdy klient został opisany przy użyciu **`r n.col`** zmiennych, wsród których znajdziemy te opisujące dane osobiste klienta (np. zmienna *Partner*, wskazująca, czy dana osoba ma partnera), jak i te określające, czy dany klient skorzystał z usług oferowanych przez firmę. Najwięcej cech pochodzi właśnie z tej drugiej grupy zmiennych.\
Większość zmiennych są zmiennymi ilośćiowymi nieporządkowymi, określającymi między innymi, czy dany klient wykupił daną telekomunikacyjną.  Przykładowo — zmienna *OnlineSecurity* informuje, czy osoba korzysta z usługi bezpieczeństwa w sieci (*Yes*), nie korzysta (*No*) czy też w ogóle nie ma dostępu do Internetu (*No internet service*).


## Brakujące wartości.
Ze wszystkich zmiennych dostępnych w ramce danych, jedynie zmienna *`r n.missing["variable"][1]`* zawiera brakujące wartości. Zawiera ich *`r n.missing["na.count"][1]`*. Wiersze, które nie przyjmują dla tej zmiennej żadnej wartości, zostaną porzucone.
Wartości brakujące są kodowane standardowo, tj. jako *NA*. Nie znajdujemy w zbiorze danych niestandardowej reprezentacji wartośći brakujących.


## Okreslenie istotności zmiennych, eliminacja rendundancji danych.
Naszym celem jest przewidzenie, czy dany klient zrezygnuje z usług firmy na podstawie dostępnych cech. W celu wyeliminowania redundancji danych, skasujemy te zmienne, które albo nie mają żadnego wpływu na decyzje klienta albo są funkcją pozostałych atrybutów.\
Atrybut **customerID** z pewnością nie ma wpływu na zachowanie konsumenckie klienta, bowiem jest jedynie jego unikalnym identyfikatorem.\
Racjonalne wydaje się również skasowanie kolumny **TotalCharges**. Zlicza ona całkowity koszt poniesiony przez klienta od początku zawarcia umowy z firmą. Tę wartość możemy bez straty informacji otworzyć, mnożąc ze sobą zmienne **tenure** oraz **MonthlyCharges** określające odpowiednio długość trwania umowy (wyrażona w miesiącach) i miesięczną taryfę za usługi.


```{r dropping irrelevant variables, include=FALSE}
dane <- dane %>%
  drop_na(all_of(n.missing$variable)) %>% # Skasuj wiersze, które mają wartości brakujące dla zmiennych z n.missing$variable
  mutate(across(all_of( c("customerID", "TotalCharges")), ~NULL)) # Skasuj redundantne kolumny

```


# Etap 2. Analiza opisowa - wskaźniki sumaryczne i wykresy.

```{r selecting numeric columns, echo=FALSE}
  num.cols <- names(dane %>% select( where(is.numeric))) # Znajdź kolumny numeryczne.

# Do poprawy - wyświetlanie liczb do 2 miejsc po przecinku. 
# Pewnie samo summary jest lepsze, ale trzeba z nazw wskaźników zrobić nazwy wierszy.
summary.df <- t(data.frame(
  Min = sapply(dane[num.cols], min),
  Mean = sapply(dane[num.cols], mean),
  Median = sapply(dane[num.cols], median),
  SD = sapply(dane[num.cols], sd),
 IQR = sapply(dane[num.cols], IQR),
 Max = sapply(dane[num.cols], max)
))

kable(summary.df, digits = 2, caption = "Wskaźniki sumaryczne dla zmiennych ciągłych",
      align = "lr")
```







