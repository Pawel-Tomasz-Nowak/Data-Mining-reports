---
title: "Sprawozdanie z listy 1"
subtitle: "Eksploracja danych"
author: "Marta Stankiewicz, Paweł Nowak  \n numery albumów: 282244 282223"
date: "`r Sys.Date()`"
header-includes:
   - \usepackage[OT4]{polski}
   - \usepackage[utf8]{inputenc}
   - \usepackage{graphicx}
   - \usepackage{float}
output: 
  pdf_document:
    toc: true
    fig_caption: yes
    fig_width: 5 
    fig_height: 4 
    number_sections: true
fontsize: 12pt 
---
```{r setup, include=FALSE, cache = TRUE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
knitr::opts_chunk$set(warning = FALSE, message = FALSE) 
knitr::opts_chunk$set(fig.pos = "H", out.extra = "", fig.align = "center")
library(dplyr)
library(tidyr)
library(kableExtra)
library(knitr)
library(ggplot2)
library(gridExtra)
```



# Etap 1. Przygotowanie danych. Podstawowe informacje o danych.

```{r Read data and libraries, include=FALSE, cache = TRUE}
# Wczytywanie ramki danych.
dane <- read.csv("WA_Fn-UseC_-Telco-Customer-Churn.csv")


```

```{r dtypes casting, counting rows and cols, include=FALSE, cache = TRUE}
# Ile jest wierszy, a ile - zmiennych?
n.row <- nrow(dane) # 7043 wierszy.
n.col <- ncol(dane) # 21 kolumn.



# Dane zawierają sporo zmiennych jakościowych nieporzadkowych, które zostały błędnie wczytane jako zmienne typu napis. 
vars.to.cast <- c("gender", "SeniorCitizen", "Partner", "Dependents", "PhoneService", "MultipleLines",
                  "InternetService", "OnlineSecurity", "OnlineBackup", "DeviceProtection",
                  "TechSupport", "StreamingTV", "StreamingMovies", "Contract", "PaperlessBilling",
                  "PaymentMethod", "Churn")

# Dokonaj konwersji na typ `factor`.
dane[vars.to.cast] <- lapply(dane[vars.to.cast], as.factor)

```




```{r missing values handling, include=FALSE, cache = TRUE}
# Znajdź cechy, które zawierają (standardowo kodowane) wartości brakujące
n.missing <- dane %>% 
  summarize(across(everything(), function(x) { sum(is.na(x)) } ) ) %>% 
  pivot_longer( everything(), names_to = "variable", values_to = "na.count" ) %>%
  filter(na.count > 0)


```

## Opis danych, rozmiar ramki danych, typy danych.

Zbiór danych, którym sie zajmujemy, zawiera informacje o **`r n.row`** klientach sieci sklepów **Telco**, która oferuje różne usługi z branży telekomunikacji, rozrywki, Internetu itp.\
Każdy klient został opisany przy użyciu **`r n.col`** zmiennych, wsród których znajdziemy te opisujące dane osobiste klienta (np. zmienna *Partner*, wskazująca, czy dana osoba ma partnera), jak i te określające, czy dany klient skorzystał z usług oferowanych przez firmę. Najwięcej cech pochodzi właśnie z tej drugiej grupy zmiennych.\
Większość zmiennych są zmiennymi ilośćiowymi nieporządkowymi, określającymi między innymi, czy dany klient wykupił daną telekomunikacyjną.  Przykładowo — zmienna *OnlineSecurity* informuje, czy osoba korzysta z usługi bezpieczeństwa w sieci (*Yes*), nie korzysta (*No*) czy też w ogóle nie ma dostępu do Internetu (*No internet service*).


## Brakujące wartości.
Ze wszystkich zmiennych dostępnych w ramce danych, jedynie zmienna *`r n.missing["variable"][1]`* zawiera brakujące wartości. Zawiera ich *`r n.missing["na.count"][1]`*.Dokonamy imputacji wartości tej zmiennej, opierając się na podejściu ze średnią.
Wartości brakujące są kodowane standardowo, tj. jako *NA*. Nie znajdujemy w zbiorze danych niestandardowej reprezentacji wartośći brakujących.


## Okreslenie istotności zmiennych, eliminacja rendundancji danych.
Naszym celem jest przewidzenie, czy dany klient zrezygnuje z usług firmy na podstawie dostępnych cech. W celu wyeliminowania redundancji danych, skasujemy te zmienne, które albo nie mają żadnego wpływu na decyzje klienta albo są funkcją pozostałych atrybutów.\
Atrybut **customerID** z pewnością nie ma wpływu na zachowanie konsumenckie klienta, bowiem jest jedynie jego unikalnym identyfikatorem.\


```{r imputation, include=FALSE, cache = TRUE}
# Obliczenie średniej dla TotalCharges, ignorując brakujące wartości
mean_value <- mean(dane$TotalCharges, na.rm = TRUE)

# Imputacja brakujących wartości średnią
dane$TotalCharges[is.na(dane$TotalCharges)] <- mean_value

```


# Etap 2. Analiza opisowa - wskaźniki sumaryczne i wykresy

## Podstawowe wskaźniki sumaryczne dla zmiennych ciągłych
```{r selecting numeric columns, echo=FALSE, cache = TRUE}
  num.cols <- names(dane %>% dplyr::select( where(is.numeric))) # Znajdź kolumny numeryczne.

# Do poprawy - wyświetlanie liczb do 2 miejsc po przecinku. 
# Pewnie samo summary jest lepsze, ale trzeba z nazw wskaźników zrobić nazwy wierszy.
summary.df <- t(data.frame(
  Min = sapply(dane[num.cols], min),
  Mean = sapply(dane[num.cols], mean),
  Median = sapply(dane[num.cols], median),
  SD = sapply(dane[num.cols], sd),
 IQR = sapply(dane[num.cols], IQR),
 Max = sapply(dane[num.cols], max)
))

kable(summary.df, digits = 2, caption = "Wskaźniki sumaryczne dla zmiennych ciągłych",
      align = "lr")
```
\newpage
## Wykresy słupkowe dla zmiennych kategorycznych
```{r echo=FALSE, fig.width = 9, fig.height = 6, cache = TRUE, fig.cap = "Rozkłady zmiennych kategorycznych"}
wykres <- function(var){
  
  ggplot(dane, aes(x = !!sym(var), fill = !!sym(var))) + 
  geom_bar() + 
  ggtitle(paste("Rozkład zmiennej", var)) + theme(legend.title = element_blank())
  
}
grid.arrange(wykres("gender"), wykres("PaymentMethod"),
             wykres("InternetService"), wykres("OnlineSecurity"))
```


```{r boxplots, echo=FALSE,fig.width = 9, fig.height = 6, cache = TRUE, fig.cap = "Wykresy pudełkowe zmiennych ciągłych"}
 boxplot_maker <- function(var){
   ggplot(dane, aes(y = !!sym(var))) + geom_boxplot() +
   ggtitle( paste("Wykres pudełkowy dla", var))+
   theme(axis.ticks.x = element_blank(), axis.text.x = element_blank())}



 grid.arrange(boxplot_maker("tenure"), boxplot_maker("MonthlyCharges"),
              boxplot_maker("TotalCharges"),
             ncol = 2)

```



```{r histograms, echo=FALSE,fig.width = 9, fig.height = 6, cache = TRUE, fig.cap = "Histogramy zmiennych ciągłych"}
 histogram_maker <- function(var, color){
   var_sd <- sd(dane[[var]])

  width <- 3.5 * (n.row)^(-1/3)*var_sd


   ggplot(dane, aes(x = !!sym(var))) + geom_histogram(binwidth = width, fill = color, color = "black") +
   ggtitle( paste("Histogram zmiennej", var))
   }

p1 <- histogram_maker("tenure", "magenta")
p2 <- histogram_maker("MonthlyCharges", "cyan")
p3 <- histogram_maker("TotalCharges", "lightgreen")

grid.arrange(p1, p2,p3, ncol = 2)

```




```{r feature relationships, echo=FALSE, fig.width = 9, fig.height = 6,fig.cap = "Wykresy rozrzutu wraz z krzywą regresji liniowej"}
p1 <- ggplot(dane, aes(x = tenure, y = MonthlyCharges)) +
  geom_point(color = "magenta") + 
  geom_smooth(color = "black",method = "lm") +
  ggtitle("Relacja tenure oraz MonthlyCharges")

p2 <- ggplot(dane, aes(x = tenure, y = TotalCharges)) +
 geom_point(color = "cyan") + 
 geom_smooth(color = "black", method ="lm") +
   ggtitle("Relacja tenure oraz TotalCharges")

p3 <- ggplot(dane, aes(x = tenure*MonthlyCharges, y = TotalCharges)) + 
  geom_point(color = "orange") + 
  geom_smooth(color = "black",method ="lm") +
  ggtitle("Relacja TotalCharges oraz tenure*MonthlyCharges")


grid.arrange(p1, p2, p3, ncol = 2)
```






