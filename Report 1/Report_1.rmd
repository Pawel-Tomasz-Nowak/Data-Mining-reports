---
title: "Sprawozdanie z listy 1"
subtitle: "Eksploracja danych"
author: "Marta Stankiewicz, Paweł Nowak  \n numery albumów: 282244 282223"
date: "`r Sys.Date()`"
header-includes:
   - \usepackage[OT4]{polski}
   - \usepackage[utf8]{inputenc}
   - \usepackage{graphicx}
   - \usepackage{float}
output: 
  pdf_document:
    toc: true
    fig_caption: true
    fig_width: 5 
    fig_height: 4 
    number_sections: true
fontsize: 12pt 
lof: true
lot: true
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = FALSE)
knitr::opts_chunk$set(warning = FALSE, message = FALSE) 
knitr::opts_chunk$set(fig.pos = "H", out.extra ='', fig.align = "center")

```

```{r importing librarries, warning=FALSE, include=FALSE}
library(dplyr)
library(tidyr)
library(kableExtra)
library(knitr)
library(ggplot2)
library(gridExtra)
```


# Etap 1. Przygotowanie danych. Podstawowe informacje o danych.

```{r Read data and libraries, include=FALSE}
# Wczytywanie ramki danych.
dane <- read.csv("WA_Fn-UseC_-Telco-Customer-Churn.csv")


```

```{r dtypes casting, counting rows and cols, include=FALSE}
# Ile jest wierszy, a ile - zmiennych?
n.row <- nrow(dane) # 7043 wierszy.
n.col <- ncol(dane) # 21 kolumn.


str(dane)
# Dane zawierają sporo zmiennych jakościowych nieporzadkowych, które zostały błędnie wczytane jako zmienne typu napis. 
vars.to.cast <- c("gender", "SeniorCitizen", "Partner", "Dependents", "PhoneService", "MultipleLines",
                  "InternetService", "OnlineSecurity", "OnlineBackup", "DeviceProtection",
                  "TechSupport", "StreamingTV", "StreamingMovies", "Contract", "PaperlessBilling",
                  "PaymentMethod", "Churn")

# Dokonaj konwersji na typ `factor`.
dane[vars.to.cast] <- lapply(dane[vars.to.cast], as.factor)

```




```{r missing values handling, include=FALSE}
# Znajdź cechy, które zawierają (standardowo kodowane) wartości brakujące
n.missing <- dane %>% 
  summarize(across(everything(), function(x) { sum(is.na(x)) } ) ) %>% 
  pivot_longer( everything(), names_to = "variable", values_to = "na.count" ) %>%
  filter(na.count > 0)


```

## Opis danych, rozmiar ramki danych, typy danych.

Zbiór danych, którym si zajmujemy, zawiera informacje o **`r n.row`** klientach sieci sklepów **Telco**, która oferuje różne usługi z branży telekomunikacji, rozrywki, Internetu itp.\
Każdy klient został opisany przy użyciu **`r n.col`** zmiennych, wśród których znajdziemy te opisujące dane osobiste klienta (np. zmienna *Partner*, wskazująca, czy dana osoba ma partnera), jak i te określające, czy dany klient skorzystał z usług oferowanych przez firmę. Najwięcej cech pochodzi właśnie z tej drugiej grupy zmiennych.\
Większość zmiennych są zmiennymi ilościowymi nieporządkowymi, określającymi między innymi, czy dany klient wykupił daną telekomunikacyjną.  Przykładowo — zmienna *OnlineSecurity* informuje, czy osoba korzysta z usługi bezpieczeństwa w sieci (*Yes*), nie korzysta (*No*) czy też w ogóle nie ma dostępu do Internetu (*No internet service*).


## Brakujące wartości.
Ze wszystkich zmiennych dostępnych w ramce danych, jedynie zmienna *`r n.missing["variable"][1]`* zawiera brakujące wartości. Zawiera ich *`r n.missing["na.count"][1]`*.Dokonamy imputacji wartości tej zmiennej, opierając się na podejściu ze średnią.
Wartości brakujące są kodowane standardowo, tj. jako *NA*. Nie znajdujemy w zbiorze danych niestandardowej reprezentacji wartości brakujących.


## Okreslenie istotności zmiennych, eliminacja rendundancji danych.
Naszym celem jest przewidzenie, czy dany klient zrezygnuje z usług firmy na podstawie dostępnych cech. W celu wyeliminowania redundancji danych, skasujemy te zmienne, które albo nie mają żadnego wpływu na decyzje klienta albo są funkcją pozostałych atrybutów.\
Atrybut **customerID** z pewnością nie ma wpływu na zachowanie konsumenckie klienta, bowiem jest jedynie jego unikalnym identyfikatorem.\


```{r imputation, include=FALSE}
# Obliczenie średniej dla TotalCharges, ignorując brakujące wartości
mean_value <- mean(dane$TotalCharges, na.rm = TRUE)

# Imputacja brakujących wartości średnią
dane$TotalCharges[is.na(dane$TotalCharges)] <- mean_value

```

\newpage
# Etap 2. Analiza opisowa - wskaźniki sumaryczne i wykresy

## Podstawowe wskaźniki sumaryczne dla zmiennych ciągłych
```{r selecting numeric columns, echo=FALSE}
  num.cols <- names(dane %>% dplyr::select( where(is.numeric))) # Znajdź kolumny numeryczne.

# Do poprawy - wyświetlanie liczb do 2 miejsc po przecinku. 
# Pewnie samo summary jest lepsze, ale trzeba z nazw wskaźników zrobić nazwy wierszy.
summary.df <- t(data.frame(
  Min = sapply(dane[num.cols], min),
  Mean = sapply(dane[num.cols], mean),
  Median = sapply(dane[num.cols], median),
  SD = sapply(dane[num.cols], sd),
 IQR = sapply(dane[num.cols], IQR),
 Max = sapply(dane[num.cols], max)
))

kable(summary.df, digits = 2, caption = "Wskaźniki sumaryczne dla zmiennych ciągłych",
      align = "lr")
```
## Wykresy słupkowe dla zmiennych kategorycznych
```{r echo=FALSE, fig.width = 9, fig.height = 8, fig.cap = "Rozkłady zmiennych kategorycznych"}
wykres <- function(var){
  
  ggplot(dane, aes(x = !!sym(var), fill = !!sym(var))) + 
  geom_bar() + 
  ggtitle(paste("Rozkład zmiennej", var)) + theme(legend.title = element_blank())
  
}

grid.arrange(wykres("gender"), wykres("Contract"),
             wykres("InternetService"), wykres("OnlineSecurity"))
```


## Wykresy pudełkowe dla zmiennych ilościowych
```{r boxplots, echo=FALSE,fig.width = 9, fig.height = 8, fig.cap = "Wykresy pudełkowe zmiennych ciągłych"}
 boxplot_maker <- function(var){
   ggplot(dane, aes(y = !!sym(var))) + geom_boxplot() +
   ggtitle( paste("Wykres pudełkowy dla", var))+
   theme(axis.ticks.x = element_blank(), axis.text.x = element_blank())
  }



 grid.arrange(boxplot_maker("tenure"), boxplot_maker("MonthlyCharges"),
              boxplot_maker("TotalCharges"),
             ncol = 2)

```


## Histogramy dla zmiennych ilościowych
```{r histograms, echo=FALSE, fig.cap="Histogramy zmiennych ciągłych", fig.height=8, fig.width=9}
 histogram_maker <- function(var, color){
   var_sd <- sd(dane[[var]])

  width <- 3.5 * (n.row)^(-1/3)*var_sd


   ggplot(dane, aes(x = !!sym(var))) + geom_histogram(binwidth = width, fill = color, color = "black") +
   ggtitle( paste("Histogram zmiennej", var))
   }

p1 <- histogram_maker("tenure", "magenta")
p2 <- histogram_maker("MonthlyCharges", "cyan")
p3 <- histogram_maker("TotalCharges", "lightgreen")

grid.arrange(p1, p2,p3, ncol = 2)

```


## Wykresy rozrzutu wraz z krzywą regresji dla zmiennych ilościowych
```{r feature relationships, echo=FALSE, fig.width = 9, fig.height = 8,fig.cap = "Wykresy rozrzutu wraz z krzywą regresji liniowej"}
p1 <- ggplot(dane, aes(x = tenure, y = MonthlyCharges)) +
  geom_point(color = "magenta") + 
  geom_smooth(color = "black",method = "lm") +
  ggtitle("Relacja tenure oraz MonthlyCharges")

p2 <- ggplot(dane, aes(x = tenure, y = TotalCharges)) +
 geom_point(color = "cyan") + 
 geom_smooth(color = "black", method ="lm") +
   ggtitle("Relacja tenure oraz TotalCharges")

p3 <- ggplot(dane, aes(x = tenure*MonthlyCharges, y = TotalCharges)) + 
  geom_point(color = "orange") + 
  geom_smooth(color = "black",method ="lm") +
  ggtitle("Relacja TotalCharges oraz tenure*MonthlyCharges")


grid.arrange(p1, p2, p3, ncol = 2)
```

## Interpretacja wykresów.
Przyglądając się rozkładowi zmiennych jakościowych, możemy dojść do wielu ciekawych wniosków. Przede wszystkim rozkład płci klientów jest jednostajny. Spośród wszystkich typów kontraktu (miesięczny, roczny, dwuletni) zdecydowanie największą popularnością cieszy się kontrakt miesięczny. Klienci korzystający z usług internetowych najchętniej korzystają ze światłowodu, chociaż druga najczęstsza opcja (tj. DSL) ma również spore grono odbiorców.
Największy niepokój budzi kompletny brak zainteresowania usługami z zakresu cyberbezpieczeństwa. Przeważająca większość konsumentów nie korzysta z tych rozwiązań mimo dostępu do łącza internetowego.
Rozkłady zmiennych ciągłych wykazują różne ciekawe właściwości. Patrząc na wykres \ref{fig:histograms} obserwujemy rozkład U-modalny dla zmiennej tenure, który jest w przybliżeniu rozkładem symetrycznym. Z kolei zmienna **TotalCharges** wyróżnia się rozkładem prawostronnie skośnym jednomodalnym. Najciekawszy rozkład wykazuje zmienna **MonthlyChargess**, który jest jednomodalny oraz prawostronnie skośny. W oczy rzuca się najwyższy słupek znajdujący się na lewo od środka histogramu. Największą zmiennością charakteryzuje się zmienna **TotalCharges**, której większość wartości kumuluje się wokół wartości 0.


# Etap 3. Analiza opisowa z podziałem na grupy

## Podstawowe wskaźniki sumaryczne dla zmiennych ciągłych z podziałem na grupy klientów lojalnych i odchodzacych
```{r table1, echo=FALSE, fig.cap="Porównanie wskaźników sumarycznych zmiennej TotalCharges dla grup klientów lojalnych i odchodzących"}

wskazniki <- function(X)
{
  wynik <- c(min(X),quantile(X,0.25), median(X), mean(X), quantile(X,0.75), max(X), var(X),
             sd(X), IQR(X))
  names(wynik) <- c("min", "Q1", "median", "mean", "Q3", "max", "var", "sd", "IQR")
  return(wynik)
}

wskazniki.dla.grup <- by(data=dane$TotalCharges, INDICES=dane$Churn, FUN=wskazniki)
# tworzymy tabele ze wskaźnikami
wskazniki.obl <- wskazniki.dla.grup
tabela    <- rbind(wskazniki.obl$No, wskazniki.obl$Yes)
row.names(tabela) <- c("lojalni", "nielojalni")
tabela %>%
    kbl(digits=2, caption="Porównanie wskaźników sumarycznych dla grup klientów lojalnych i odchodzących na podstawie zmiennej TotalCharges") %>%
        kable_styling(latex_options = c("HOLD_position")) 


```

```{r table2, echo=FALSE, fig.cap="Porównanie wskaźników sumarycznych zmiennej MonthlyCharges dla grup klientów lojalnych i odchodzących"}

wskazniki <- function(X)
{
  wynik <- c(min(X),quantile(X,0.25), median(X), mean(X), quantile(X,0.75), max(X), var(X),
             sd(X), IQR(X))
  names(wynik) <- c("min", "Q1", "median", "mean", "Q3", "max", "var", "sd", "IQR")
  return(wynik)
}

wskazniki.dla.grup <- by(data=dane$MonthlyCharges, INDICES=dane$Churn, FUN=wskazniki)
# tworzymy tabele ze wskaźnikami
wskazniki.obl <- wskazniki.dla.grup
tabela    <- rbind(wskazniki.obl$No, wskazniki.obl$Yes)
row.names(tabela) <- c("lojalni", "nielojalni")
tabela %>%
    kbl(digits=2, caption="Porównanie wskaźników sumarycznych dla grup klientów lojalnych i odchodzących na podstawie zmiennej MonthlyCharges") %>%
        kable_styling(latex_options = c("HOLD_position"))


```

```{r table3, echo=FALSE, fig.cap="Porównanie wskaźników sumarycznych zmiennej tenure dla grup klientów lojalnych i odchodzących"}

wskazniki <- function(X)
{
  wynik <- c(min(X),quantile(X,0.25), median(X), mean(X), quantile(X,0.75), max(X), var(X),
             sd(X), IQR(X))
  names(wynik) <- c("min", "Q1", "median", "mean", "Q3", "max", "var", "sd", "IQR")
  return(wynik)
}

wskazniki.dla.grup <- by(data=dane$tenure, INDICES=dane$Churn, FUN=wskazniki)
# tworzymy tabele ze wskaźnikami
wskazniki.obl <- wskazniki.dla.grup
tabela    <- rbind(wskazniki.obl$No, wskazniki.obl$Yes)
row.names(tabela) <- c("lojalni", "nielojalni")
tabela %>%
    kbl(digits=2, caption="Porównanie wskaźników sumarycznych dla grup klientów lojalnych i odchodzących na podstawie zmiennej tenure") %>%
        kable_styling(latex_options = c("HOLD_position"))


```


## Wykresy pudełkowe dla zmiennych ilościowych z podziałem na grupy klientów lojalnych i odchodzacych
```{r gruped boxplots, echo=FALSE,fig.width = 9, fig.height = 8, fig.cap = "Wykresy pudełkowe zmiennych ciągłych z podziałem na grupy"}
dane1 <- dane %>%
  mutate(Churn = factor(Churn, levels = c("No", "Yes"), labels = c("Loyal", "Disloyal")))

boxplot_maker <- function(var) {
  ggplot(dane1, aes(x = Churn, y = !!sym(var), fill = Churn)) + 
    geom_boxplot() +
    ggtitle(paste("Wykres pudełkowy dla", var)) +
    theme_minimal() +
    theme(axis.title.x = element_blank(), legend.position = "none")
}

grid.arrange(
  boxplot_maker("tenure"), boxplot_maker("MonthlyCharges"),
  boxplot_maker("TotalCharges"),
  ncol = 2
)

```
## Wykresy słupkowe dla zmiennych kategorycznych z podziałem na grupy klientów lojalnych i odchodzacych
```{r grouped barplots, echo=FALSE, fig.width = 9, fig.height = 10, fig.cap = "Rozkłady zmiennych kategorycznych z podziałem na klientów lojalnych i nielojalnych"}

factors.vars <- names(select_if(dane1, is.factor))

plot <- function(var){
  
   return(ggplot(dane1, aes(x = !!sym(var), fill = Churn)) + geom_bar( ) +
    ggtitle(paste("Wykres słupkowy", var)) + theme(axis.text.x = element_text(angle = 20, hjust = 1)))
  
}

grid.arrange(plot("SeniorCitizen"), plot("Contract"),
             plot("PaymentMethod"), plot("InternetService"), plot("PaperlessBilling"), 
             plot("TechSupport"))
```

## Analiza wyników
Analizując wskaźniki sumaryczne dla zmiennych ciągłych (tabele ref) oraz interpretując wykresy pudełkowe (wykresy ref), można zauważyć, że najlepsze rozróżnienie między klientami, którzy nadal korzystają z usług firmy, a tymi, którzy zrezygnowali, zapewnia zmienna **tenure**, czyli liczba miesięcy, przez które klient pozostawał w firmie. To właśnie w tej zmiennej występuje największa różnica między medianami dla obu grup – lojalnych i nielojalnych klientów. Warto również zwrócić uwagę na pozostałe dwie zmienne, **MonthlyCharges** oraz **TotalCharges**. Klienci, którzy zrezygnowali z usług, ponosili średnio wyższe miesięczne opłaty niż ci, którzy pozostali. W przypadku rozkładu zmiennej **TotalCharges** warto zauważyć, że choć średnia wartość całkowitych wydatków klientów nielojalnych jest mniejsza, to próbki odstające w tej grupie znacznie przewyższają koszty ponoszone przez klientów lojalnych. 
