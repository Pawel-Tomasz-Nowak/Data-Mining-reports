---
title: "Sprawozdanie z listy 2"
subtitle: "Eksploracja danych"
author: "Marta Stankiewicz (282244)  \n Paweł Nowak (282223)"
date: "`r Sys.Date()`"
header-includes:
   - \usepackage[OT4]{polski}
   - \usepackage[utf8]{inputenc}
   - \usepackage{graphicx}
   - \usepackage{float}
output: 
  pdf_document:
    toc: true
    fig_caption: true
    fig_width: 5 
    fig_height: 4 
    number_sections: true
fontsize: 12pt 
lof: true
lot: true
---


---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = FALSE)
knitr::opts_chunk$set(warning = FALSE, message = FALSE) 
knitr::opts_chunk$set(fig.pos = "H", out.extra ='', fig.align = "center")

```

```{r importing libraries, warning=FALSE, include=FALSE}
# Importing necessary libraries.
library(datasets)
library(dplyr)
library(ggplot2)
library(GGally)
library(gridExtra)
library(arules)
library(knitr)
```



```{r data reading, include=FALSE}
# Reading the 'iris' data set.
data("iris") 
iris_df <- iris


num.cols <- colnames(iris_df %>% dplyr::select( where(is.numeric))) # Find the numerical variables.
print(num.cols)
```


# Ocena zdolności separacyjnych zmiennych, dyskretyzacja zmiennych ciągłych.
## Ocena zdolności dyskryminacyjnych zmiennych ciągłych. {#discriminative_power_compare}

W celu zbadania zdolności dyskryminacyjnej cech, posłużymy się wykresem skrzypcowo-pudełkowym (tj. wykresem skrzypcowym wraz z wykresem pudełkowym). 
```{r violin boxplots, echo=FALSE, fig.width = 9, fig.height = 8, fig.cap = "Wykresy skrzypcowo-pudełkowe dla zmiennych ciągłych"}
  # Create a violin-with-box plot for each continous variable and arrange them in a figure.
    violin.plot.box_maker <- function(var){
    ggplot(data = iris_df, 
           aes(x = Species, y = iris_df[[var]], fill = Species)) +
      geom_violin(alpha = 0.2) +
      geom_boxplot(width = 0.15) +
        ylab(gsub("\\.", " ", var)) + 
        labs(title = paste("Wykres skrzypcowo-pudełkowy zmiennej\n",var))
    
    }
    
    grid.arrange(violin.plot.box_maker("Sepal.Length"), violin.plot.box_maker("Sepal.Width"),
               violin.plot.box_maker("Petal.Length"),
              violin.plot.box_maker("Petal.Width")
              )

```

Z wykresów \ref{fig:violin boxplots} wnioskujemy, że największe zdolności dyskryminacyjne wykazuje zmienna *Petal.Width*. Z kolei najmniejsze zdolności do separacji gatunków obserwujemy u zmiennej *Sepal.Width*.
\newpage

## Porównanie róznych metod dyskretyzacji nienadzorowanej. {#discretization_intro}
Dla wymienionych wyżej zmiennych (tj. *Petal.Width* oraz *Sepal.Width*) zastosujemy teraz różne techniki przedziałowania (dyskretyzacji) według, odpowiednio, **stałej szerokości** przedziału, **równej częstości**, **algorytmu K-średnich**, **stałych granicach** przedziałów ustalonych przez użytkownika.


```{r discretization, include = FALSE}
var_discretization <- function(df, var){
  # Estimate the mean and sd of the variable (we'll use these values for fixed-type discretization)
  var.vec <- df[[var]]
  
  mean.est <- mean(var.vec)
  sd.est <- sd(var.vec)
  
  
  # Oparta na równej częstotliwości.
  var.discr.freq <- discretize(var.vec, 
                               method = "frequency", 
                               breaks = 3,
                               label = c("Krótka", "Średnia", "Długa"))
  
  # equal-width discretization
  var.discr.width <- discretize(var.vec, 
                                method = "interval", 
                                breaks = 3,
                                label = c("Krótka", "Średnia", "Długa"))
  
  # cluster discretization
  var.discr.cluster <- discretize(var.vec, 
                                  method = "cluster", 
                                  breaks = 3,
                                  label = c("Krótka", "Średnia", "Długa"))
  
  # user-specified breaks bounds.
  var.discr.user <- discretize(var.vec,
                               method = "fixed",
                               breaks = c(-Inf, mean.est-sd.est, mean.est+sd.est, Inf),
                               label = c("Krótka", "Średnia", "Długa"))

  
  
  # Store discretization result in a dataframe.
  df.discr_vals <- data.frame("equal_frequency" = var.discr.freq,
                              "equal_width" = var.discr.width,
                              "cluster" = var.discr.cluster,
                              "fixed_bounds"= var.discr.user
                              )
  
  # Rename the columns.
  renamed.columns <- sapply(colnames(df.discr_vals), function(x){ paste(var, " ", x) })
  colnames(df.discr_vals) = renamed.columns
  
  return(df.discr_vals)
  }

```

```{r discretization method comparison, echo=FALSE}
most_common_class <- function(row) {
  # Zlicz ile razy każda klasa występuje w wierszu
  tab <- table(as.character(row))
  # Zwróć klasę z największą liczbą wystąpień (w przypadku remisu bierze pierwszą)
  names(which.max(tab))
}

do_class_match <- function(row){
  # Porównaj każdy element z ostatnim elementem w wierszu
  return(as.integer(row[-length(row)] == row[length(row)]))
}

evaluate_method <- function(df, var){
  # Discretize the variable.
  df.discr_vals <- var_discretization(df, var)
  
  # Find the most common class row-wise.
  df.discr_vals$most.common.class <- apply(df.discr_vals, 1, most_common_class)
    
  # For each method, find the percentage of matches.
  result_match <- t(apply(df.discr_vals, 1, do_class_match)) %>% 
    apply(2, function(x){ 100 * sum(x) / nrow(df.discr_vals)}) %>%
    round(2)
  
  
  # The table with the metrics of accuracy of discretization.
  acc_table <- kable(t(data.frame(Skutecznosc = result_match)), 
                col.names = c("Przedziałowanie według równej częstotliwość", 
                              "Przedziałowanie według równej szerokości", 
                              "Dyskretyzacja oparta na algorytmie K-średnich", 
                              "Stałe granice przedziału"), 
                row.names = FALSE, 
                caption = paste("Skuteczność wybranych metod dyskretyzacji dla zmiennej", gsub("\\.", " ",var)))
  
  # Return the table
  return(acc_table)
}


```

### Metodologia oceny skuteczności dyskretyzacji.
Aby ocenić skuteczność każdej ze [wspomnianych metod](#discretization_intro), przyjęliśmy następującą metodologię.
Najpierw dokonaliśmy przedziałowania każdego przypadku, korzystając ze wszystkich metod, a następnie wybraliśmy tę klasę, która występuje najczęściej (w przypadku tzw. "remisu" wybierana jest dowolna klasa). Następnie sprawdzaliśmy, w ilu przypadkach wynik przedziałowania każdej metody zgadzał się ze zagregowaną klasą. Tę liczbę podzieliliśmy przez liczbę wszystkich przypadków, aby uzyskać skuteczność metody dyskretyzacji wyrażoną w procentach. Porównanie róznych metod przedziałowania zostały przedstawione poniżej
```{r binning_results1, echo=FALSE}
discretization_results <- evaluate_method(iris, "Sepal.Width")
discretization_results
```


```{r binning_results2, echo=FALSE}
discretization_results <- evaluate_method(iris, "Petal.Width")
discretization_results
```

### Wnioski dotyczące skuteczności przedziałowania.
<!-- Wtf czemu latex nie widzi referencji do binning_results1? -->
Z tabel \ref{tab:binning_results1} oraz \ref{tab:binning_results2} możemy wywnioskować, że w obu przypadkach największą skutecznością charakteryzuje się metoda dyskretyzacji oparta na **algorytmie K-średnich**. Z kolei najgorszą skuteczność przedziałowania obserwujemy dla metody opartej na **stałych granicach** przedziału.
Wyniki dyskretyzacji zastosowanej dla zmiennej *Petal.Width* znaczącą rożnią się od wyników przedziałowania zastosowanego dla atrybutu *Sepal.Width*. 
Jest to zgodne z intuicją — jak wykazaliśmy [wcześniej](#discriminative_power_compare), najgorsze zdolności separacyjne klas wykazuje właśnie zmienna **Sepal.Width**, co znacząco wpływa na niską skuteczność metod przedziałowania. Analogiczna zależność występuje w przypadku cechy **Petal.Width**, która z kolei charakteryzowała się wysokimi zdolnościami dyskryminacyjnymi, co przełożyło się na wysoką dokładność podejść dyskretyzacji. 


