czas.outer.product5000
czas.outer5000
#przykład wektora
x <- c(3,2,1,6,55,-2,3,7)
liczba.parzystych <- 0
liczba.nieparzystych <- 0
for (element in x) {
if (element%%2==0){
liczba.parzystych <- liczba.parzystych + 1
} else {
liczba.nieparzystych <- liczba.nieparzystych + 1
}
}
print(paste0("Liczba elementów parzystych:", liczba.parzystych))
print(paste0("Liczba elementów nieparzystych:", liczba.nieparzystych))
#za pomocą wektoryzacji
warunek.parzystosc <- (x%%2==0)
sum(warunek.parzystosc)
sum(!warunek.parzystosc)
A <- matrix(c(1,2,3,4,5,6), ncol=2, nrow=3)
A
t(A)
transponowana <- matrix(0, ncol=nrow(A), nrow=ncol(A)) #dobre wymiary, wartości=0
for (i in 1:nrow(A)) {
for (j in 1:ncol(A)) {
transponowana[j, i] <- A[i, j]
}
}
print(transponowana)
funkcja.kwadratowa <- function(a,b,c) {
function(x) a*(x^2)+(b*x)+c
}
f <- funkcja.kwadratowa(1,0,0)
g <- funkcja.kwadratowa(-2,3,1)
h <- funkcja.kwadratowa(0,11,3)
curve(f, from=-20, to=20)
curve(g, from=-20, to=20)
curve(h, from=-20, to=20)
transformuj <- function(wskaznik = "", x=c(...)){
wynik <- switch(wskaznik,
centrowanie = x - mean(x),
skalowanie =  x/sd(x),
standaryzacja = (x-mean(x))/sd(x),
min.max = (x - min(x))/(max(x)-min(x)),
print("nieznany wskaznik")
)
return(wynik)
}
x <- c(1,2,3,4,5,6)
transformuj("centrowanie", x)
mean(transformuj("centrowanie", x))
transformuj("skalowanie", x)
sd(transformuj("skalowanie", x))
transformuj("standaryzacja", x)
transformuj("min.max", x)
min(transformuj("min.max", x))
max(transformuj("min.max", x))
library(microbenchmark)
wartosci.do.porownania <- c(5,15,25,30)
silnia <- function(n) {
if (n == 0) {
return(1)
} else {
return(n * silnia(n - 1))
}
}
for (n in wartosci.do.porownania){
wynik <- microbenchmark(
funkcja.factorial = factorial(n),
silnia = silnia(n),
times = 1000L
)
wynik
}
wynik
funkcja_max <-function(x){
maksimum <- max(x)
return (maksimum)
}
#pętla while
funkcja.max.while <- function(x){
i <- 1
max_val <- x[1]
while (i <= length(x)){
if (x[i]> max_val){
max_val <- x[i]
}
i <- i+1
}
return(max_val)
}
#fpętla repeat
funkcja.max.repeat <- function(x){
i <- 1
max_val <- x[1]
repeat {
if (x[i] > max_val){
max_val <- x[i]
}
i <-  i+1
if (i>length(x)){
break
}
}
return (max_val)
}
#pętla for
funkcja.max.for <- function(x){
max_val <- x[1]
for (element in x){
if (element>max_val) {
max_val <- element
}
}
return(max_val)
}
n <- c(10,50,100,200,300) # długość wektora
for (n in n){
print(paste0("Porównanie czasów dla długości wektora n =", n))
x <- runif(n)
wyniki <- microbenchmark(
funkcja_max = funkcja_max(x),
funkcja.max.while = funkcja.max.while(x),
funkcja.max.repeat = funkcja.max.repeat(x),
funkcja.max.for = funkcja.max.for(x),
times = 1000L
)
print(wyniki)
}
n <- 10
m <- 5
A <- matrix(runif(n*m), nrow=n, ncol = m)
srednia.kolumn.macierzy <- function(A){
sumy_kolumn <-  colSums(A)
srednie <- sumy_kolumn/nrow(A)
return(srednie)
}
srednia.apply <- apply(A, MARGIN=2, FUN=mean)
porownanie <- function(A){
wyniki <- microbenchmark(
srednia.kolumn.macierzy = srednia.kolumn.macierzy(A),
srednia.apply = srednia.apply,
times = 1000L
)
return(wyniki)
}
porownanie(A)
outer.product <- function(x=c(...), y=c(...)){
M <- matrix(0, ncol=length(y), nrow=length(x))
for (x.i in 1:length(x)){
for (y.i in 1:length(y)) {
M[x.i, y.i] <-  x[x.i] * y[y.i]
}
}
return(M)
}
x1 <- runif(100)   # wektor x o długości 100
y1 <- runif(100)
x2 <- runif(1000)
y2 <- runif(1000)
x3 <- runif(5000)
y3 <- runif(5000)
# dla wektoróo dlugosci 100
czas.outer.produc100<- system.time(outer.product(x1, y1))
czas.outer100 <- system.time(outer(x1, y1))
czas.outer.product1000 <- system.time(outer.product(x2, y2))
czas.outer1000 <- system.time(outer(x2, y2))
czas.outer.product5000 <- system.time(outer.product(x3, y3))
czas.outer5000 <- system.time(outer(x3, y3))
czas.outer.produc100
czas.outer100
czas.outer.product1000
czas.outer1000
czas.outer.product5000
czas.outer5000
x <- c(3,15,6,2,5,23,2,0,7,11,8,4)
# 1a
y <- which(x==max(x))
paste("Indeks(y) elementu maksymalnego:", y)
z <- which(x==min(x))
paste("Indeks(y) elementu minimalnego:", z)
# 1b
liczby.parzyste.indeksy <- x[seq(2, length(x), 2)]
x <- c(3,15,6,2,5,23,2,0,7,11,8,4)
# 1b
liczby.parzyste.indeksy <- x[seq(2, length(x), 2)]
liczby.parzyste.indeksy
y <- sum(liczby.parzyste.indeksy)
paste("Suma liczb o indeksach parzystych =", y)
liczby.nieparzyste.indeksy <- x[seq(1, length(x), 2)]
liczby.nieparzyste.indeksy
z <- sum(liczby.nieparzyste.indeksy)
paste("Suma liczb o indeksach nieparzystych =", z)
# 1c
y <- mean(x)
paste("Średnia elementów wektora x wynosi =", y)
z <- sum(x>y)
paste("Liczba elementów x wiekszych od średniej:", z)
length(x)
# 1d
x1 <- x[-c(2, 7, 11)]
x1
# 1e
x2 <- x #x2 jest taki sam, ale nie ten sam
x2[x2%%2 == 0] <- x[x%%2 == 0]*-1 #tam gdzie x2 ma parzyste wartości zmieniam je na ujemne
x2
#_______________________________________________________________________________
# Wykorzystując wyłącznie funkcje rep() i seq(), wygeneruj wektory
# zawierające następujące regularne sekwencje:
#
#  (5, 5, 5, 5, 5, 4, 4, 4, 4, 3, 3, 3, 2, 2, 1)
#  (“a”, “b”, “c”, “a”, “b”, “c”, “a”, “b”, “c”)
#  (“a”, “a”, “a”, “b”, “b”, “b”, “c”, “c”, “c”)
#  (1, 3, 5, 7, 9, 11)
#_______________________________________________________________________________
# 2a
x <- seq(5,1)
rep(x, c(5,4,3,2,1))
rep(c("a", "b", "c"), times=3)
# 2d
seq(1, 11, 2)
# b. oblicz odchylenia standardowe (ang. standard deviations) Sx, Sy
#
# c. oblicz współczynnik korelacji liniowej rho
#
# d. porównaj z wynikami otrzymanymi z wykorzystaniem odpowiednich wbudowanych
#    funkcji (w szczególności: x%*%y - iloczyn skalarny wektorów x i y,
#                              sd(x) – odchylenie standardowe x,
#                              cor(x,y) - współczynnik korelacji x i y.)
#_______________________________________________________________________________
# tworzenie wektora x oraz wektora y
x <- c(14, 6, 19, 1, 16,7)
y <- c(9, 1, 5, 13,5 ,17)
# 3a
z <- x*y
iloczyn <- sum(z)
iloczyn
x%*%y
# b. oblicz odchylenia standardowe (ang. standard deviations) Sx, Sy
#
# c. oblicz współczynnik korelacji liniowej rho
#
# d. porównaj z wynikami otrzymanymi z wykorzystaniem odpowiednich wbudowanych
#    funkcji (w szczególności: x%*%y - iloczyn skalarny wektorów x i y,
#                              sd(x) – odchylenie standardowe x,
#                              cor(x,y) - współczynnik korelacji x i y.)
#_______________________________________________________________________________
# tworzenie wektora x oraz wektora y
x <- c(14, 6, 19, 1, 16,7)
y <- c(9, 1, 5, 13,5 ,17)
# 3a
z <- x*y
iloczyn <- sum(z)
iloczyn
# 3b
x_pod <- mean(x)
y_pod <- mean(y)
S.x <- sqrt(sum((x-x_pod)**2)/(length(x)-1))
S.x
S.y <- sqrt(sum((y-y_pod)**2)/(length(y)-1))
S.y
# 3c
wsp_kor <- sum((x-x_pod)*(y-y_pod))/sqrt(sum((x-x_pod)**2)*sum((y-y_pod)**2))
wsp_kor
# 3d
x%*%y == iloczyn
sd(x) == S.x
sd(y) == S.y
cor(x,y) == wsp_kor
A <- matrix(c(1,2,3,4,5,6), nrow=3, ncol=2)
sd(y)
S.y
sd(y) == S.y
sd(y) == S.y
sd(x) == S.x
S.y <- sqrt(sum((y-y_pod)**2)/(length(y)-1))
S.y
sd(y) == S.y
S.y <- sqrt(sum((y-y_pod)^22)/(length(y)-1))
sd(y) == S.y
all.equal(sd(y), S.y)
S.y <- sqrt(sum((y-y_pod)^2)/(length(y)-1))
sd(y) == S.y
all.equal(sd(y), S.y)
# b. oblicz odchylenia standardowe (ang. standard deviations) Sx, Sy
#
# c. oblicz współczynnik korelacji liniowej rho
#
# d. porównaj z wynikami otrzymanymi z wykorzystaniem odpowiednich wbudowanych
#    funkcji (w szczególności: x%*%y - iloczyn skalarny wektorów x i y,
#                              sd(x) – odchylenie standardowe x,
#                              cor(x,y) - współczynnik korelacji x i y.)
#_______________________________________________________________________________
# tworzenie wektora x oraz wektora y
x <- c(14, 6, 19, 1, 16,7)
y <- c(9, 1, 5, 13,5 ,17)
# 3a
z <- x*y
iloczyn <- sum(z)
iloczyn
# 3b
x_pod <- mean(x)
y_pod <- mean(y)
S.x <- sqrt(sum((x-x_pod)**2)/(length(x)-1))
S.x
S.y <- sqrt(sum((y-y_pod)**2)/(length(y)-1))
S.y
# 3c
wsp_kor <- sum((x-x_pod)*(y-y_pod))/sqrt(sum((x-x_pod)**2)*sum((y-y_pod)**2))
wsp_kor
# 3d
x%*%y == iloczyn
sd(x) == S.x
sd(y) == S.y
all.equal(sd(y), S.y)
cor(x,y) == wsp_kor
#   [16 18 12  9]
#   [6  19 17  3]
#   [2  11  8  7]
#
# wykorzystując w tym celu:
#
# a. funkcję matrix(),
# b. funkcję rbind() lub cbind().
#_______________________________________________________________________________
# 1a
A <- matrix(c(14,16,6,2,15,18,19,11,10,12,17,8,20,9,3,7),4,4)
A
# 1b
A <- cbind(c(14,16,6,2),c(15,18,19,11),c(10,12,17,8),c(20,9,3,7))
A
#_______________________________________________________________________________
#-------------------------------zadanie 2-----------------------------------
#_______________________________________________________________________________
# Sprawdź, jakie wyniki otrzymamy wykonując następujące działania:
# A+10, 1/A, A^2 i A^(-1).
#_______________________________________________________________________________
B <- A+10
B # do każej wartości w macierzy dodane jest 10
C <- 1/A
C # macierz wartości odwrotnych
D <- A^2
D # każda wartość w macierzy jest podniesiona do kwadratu
E <- A^(-1)
E # tak samo jak w C
#_______________________________________________________________________________
# Wybierając odpowiedni podzbiór macierzy A, wyznacz:
#
# a. macierz A1 zawierającą wyłącznie elementy macierzy A znajdujące się
#    w drugim i trzecim wierszu oraz wszystkich kolumnach oprócz pierwszej,
#
# b. macierz A2 zawierającą wyłącznie te elementy macierzy A, które znajdują się
#    w nieparzystych wierszach i parzystych kolumnach.
#_______________________________________________________________________________
# 3a
A1 <- A[c(2,3), -1]
A1
# 3b
A2 <- A[seq(1,4,2), seq(2,4,2)]
A2
#_______________________________________________________________________________
#-------------------------------zadanie 5-----------------------------------
#_______________________________________________________________________________
# Wykorzystując funkcję diag() wyznacz ślad macierzy A.
#_______________________________________________________________________________
x <- diag(A)
x
sum(x) #ślad macierzy to suma elementów na diagonali
#_______________________________________________________________________________
#-------------------------------zadanie 5-----------------------------------
#_______________________________________________________________________________
# Wykorzystując funkcję diag() wyznacz ślad macierzy A.
#_______________________________________________________________________________
x <- diag(A)
x
sum(x) #ślad macierzy to suma elementów na diagonali
wyznacznik <- det(A)
wyznacznik #rózny od zera, zatem jest odwracalna
A.inv <-  solve(A)
A.inv
A%*%A.inv #sprawdzenie czy otrzymaliśmy macierz jednostkową
wyznacznik != 0#rózny od zera, zatem jest odwracalna
A.inv <-  solve(A)
A.inv
A%*%A.inv #sprawdzenie czy otrzymaliśmy macierz jednostkową
D <- (A+t(A))/2
D
t(D) == D #symetria
#_______________________________________________________________________________
#-------------------------------zadanie 8-----------------------------------
#_______________________________________________________________________________
# Wykorzystując funkcję apply() wyznacz wartości maksymalne i minimalne
# dla poszczególnych wierszy i kolumn macierzy A.
#_______________________________________________________________________________
apply(A, MARGIN=1, FUN=max)
apply(A, MARGIN=1, FUN=min)
apply(A, MARGIN=2, FUN=max)
apply(A, MARGIN=2, FUN=min)
print(str(pracownik))
pracownik <- list(nazwisko="Kowalski", wiek=42, staz.pracy=5,
zatrudnienie=list(
pelny.etat=TRUE,
stanowisko="recepcjonista",
wynagrodzenie=6000))
pracownik
print(str(pracownik))
pracownik$staz.pracy
pracownik$zatrudnienie$wynagrodzenie
str(pracownik)
mniej_informacji <- list(wiek=pracownik$wiek, staz.pracy=pracownik$staz.pracy)
mniej_informacji
pracownik$zatrudnienie$wynagrodzenie <- 7500
pracownik$zatrudnienie$stanowisko <- "kierownik"
pracownik
# Utwórz w R wektor znakowy
#
# wyksztalcenie=(“wyzsze”,“zawodowe”, “srednie”,“srednie”, “wyzsze”,“srednie”,
#                “zawodowe”,“srednie”, “wyzsze”,“srednie”),
#
# zawierający informacje nt. wykształcenia pewnej grupy osób.
# Następnie dokonaj konwersji tego wektora na typ czynnikowy (factor),
# narzucając (jeżeli jest to uzasadnione) odpowiednią kolejność poziomów
# (levels).
#_______________________________________________________________________________
wyksztalcenie <- c("wyzsze", "zawodowe", "srednie","srednie", "wyzsze",
"srednie","zawodowe","srednie", "wyzsze","srednie")
wyksztalcenie.factor <- factor(wyksztalcenie)
wyksztalcenie.factor
wyksztalcenie.factor.ordered <- factor(wyksztalcenie, ordered=TRUE,
levels=c("srednie","zawodowe", "wyzsze"))
wyksztalcenie.factor.ordered
# Utwórz w R wektor znakowy
#
# wyksztalcenie=(“wyzsze”,“zawodowe”, “srednie”,“srednie”, “wyzsze”,“srednie”,
#                “zawodowe”,“srednie”, “wyzsze”,“srednie”),
#
# zawierający informacje nt. wykształcenia pewnej grupy osób.
# Następnie dokonaj konwersji tego wektora na typ czynnikowy (factor),
# narzucając (jeżeli jest to uzasadnione) odpowiednią kolejność poziomów
# (levels).
#_______________________________________________________________________________
wyksztalcenie <- c("wyzsze", "zawodowe", "srednie","srednie", "wyzsze",
"srednie","zawodowe","srednie", "wyzsze","srednie")
wyksztalcenie.factor.ordered <- factor(wyksztalcenie, ordered=TRUE,
levels=c("srednie","zawodowe", "wyzsze"))
wyksztalcenie.factor.ordered
ile.osob <- table(wyksztalcenie.factor.ordered)
ile.osob
podzbior
# c.  samochody o najmniejszym i największym zużyciu paliwa biorąc pod uwagę
#     jazdę miejską (zmienna MPG.city),
#
# d.  liczbę aut produkowanych w USA (Origin==“USA”) oraz
#     importowanych (Origin==“non-USA”),
#
# e.  podzbiór zawierający jedynie zmienne Length, Width i Weight
#     dla parzystych wierszy.
#_______________________________________________________________________________
# 1a
library(MASS)
data(Cars93)
mean(Cars93$EngineSize)
# 1e
podzbior <-  Cars93[seq(2,93,2), c("Length", "Width", "Weight")]
podzbior
grupa.osob <- data.frame(
wiek = c(70,66,71,57,45,48),
wyksztalcenie = c("zawodowe", "srednie","srednie","wyzsze","zawodowe","wyzsze"),
plec = c("mezczyzna","kobieta","mezczyzna","kobieta","kobieta","mezczyzna"),
cisnienie.skurczowe = c(143, 123, 167, 150, 130, 138),
puls = c(99,60,83,67,70,75))
is.numeric(grupa.osob$wiek)
is.factor(grupa.osob$wyksztalcenie)
grupa.osob$wyksztalcenie <- factor(grupa.osob$wyksztalcenie, levels=c("srednie","zawodowe","wyzsze"), ordered=TRUE)
is.factor(grupa.osob$plec)
grupa.osob$plec <- as.factor(grupa.osob$plec)
is.numeric(grupa.osob$cisnienie.skurczowe)
is.numeric((grupa.osob$puls))
str(grupa.osob)
setwd("C:/Users/marta/OneDrive/Pulpit/Data mining rep/Report 3")
knitr::opts_chunk$set(echo = FALSE, cache = FALSE)
knitr::opts_chunk$set(warning = FALSE, message = FALSE, include = FALSE)
knitr::opts_chunk$set(fig.pos = "H", out.extra = '', fig.align = "center",
fig.height = 4, fig.width =6)
knitr::opts_chunk$set(dev.args = list(encoding = "CP1250.ENC"))
# Import necessary librarries
library(datasets)
library(caret)
install.packages("recipes")
install.packages("future")
install.packages("recipes")
library(caret)
# Import necessary librarries
library(datasets)
library(caret)
library(reshape2)
library(ggplot2)
library(rlang)
library(dplyr)
library(tidyr)
library(class)
library(rpart)
install.packages("caret")
knitr::opts_chunk$set(echo = FALSE, cache = FALSE)
knitr::opts_chunk$set(warning = FALSE, message = FALSE, include = FALSE)
knitr::opts_chunk$set(fig.pos = "H", out.extra = '', fig.align = "center",
fig.height = 4, fig.width =6)
knitr::opts_chunk$set(dev.args = list(encoding = "CP1250.ENC"))
# Import necessary librarries
library(datasets)
library(caret)
install.packages("caret")
